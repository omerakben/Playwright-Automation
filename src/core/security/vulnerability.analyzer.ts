import { writeFileSync } from 'fs';
import { join } from 'path';
import logger from '../logger';
import { SecurityScanResult } from './scanner';
import { AlertRisk, ZAPAlert } from './zap.client';

/**
 * Vulnerability analysis options
 */
export interface VulnerabilityAnalysisOptions {
  includeEvidence?: boolean;
  includeSolution?: boolean;
  includeReference?: boolean;
  groupByRisk?: boolean;
  groupByType?: boolean;
  minRiskLevel?: AlertRisk;
}

/**
 * Vulnerability report format
 */
export interface VulnerabilityReport {
  summary: {
    total: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  };
  riskDistribution: {
    [key in AlertRisk]: number;
  };
  topVulnerabilities: {
    type: string;
    count: number;
    risk: AlertRisk;
  }[];
  details: {
    [key in AlertRisk]: {
      [type: string]: ZAPAlert[];
    };
  };
}

/**
 * Vulnerability analyzer class
 */
export class VulnerabilityAnalyzer {
  private static instance: VulnerabilityAnalyzer;

  private constructor() {}

  /**
   * Get singleton instance
   */
  public static getInstance(): VulnerabilityAnalyzer {
    if (!VulnerabilityAnalyzer.instance) {
      VulnerabilityAnalyzer.instance = new VulnerabilityAnalyzer();
    }
    return VulnerabilityAnalyzer.instance;
  }

  /**
   * Analyze scan results
   */
  public analyzeScanResult(
    result: SecurityScanResult,
    options: VulnerabilityAnalysisOptions = {},
  ): VulnerabilityReport {
    try {
      const report: VulnerabilityReport = {
        summary: result.summary,
        riskDistribution: this.calculateRiskDistribution(result),
        topVulnerabilities: this.identifyTopVulnerabilities(result),
        details: this.organizeVulnerabilityDetails(result, options),
      };

      logger.info('Vulnerability analysis completed', { summary: report.summary });
      return report;
    } catch (error) {
      logger.logError('Failed to analyze vulnerabilities', error);
      throw error;
    }
  }

  /**
   * Calculate risk distribution
   */
  private calculateRiskDistribution(result: SecurityScanResult): {
    [key in AlertRisk]: number;
  } {
    return {
      [AlertRisk.High]: result.summary.high,
      [AlertRisk.Medium]: result.summary.medium,
      [AlertRisk.Low]: result.summary.low,
      [AlertRisk.Info]: result.summary.info,
    };
  }

  /**
   * Identify top vulnerabilities
   */
  private identifyTopVulnerabilities(result: SecurityScanResult): {
    type: string;
    count: number;
    risk: AlertRisk;
  }[] {
    const vulnerabilityTypes = new Map<string, { count: number; risk: AlertRisk }>();

    // Count vulnerabilities by type
    Object.entries(result.alerts).forEach(([risk, alerts]) => {
      alerts.forEach((alert) => {
        const key = alert.alert;
        const current = vulnerabilityTypes.get(key) || { count: 0, risk: risk as AlertRisk };
        vulnerabilityTypes.set(key, {
          count: current.count + 1,
          risk: risk as AlertRisk,
        });
      });
    });

    // Convert to array and sort
    return Array.from(vulnerabilityTypes.entries())
      .map(([type, { count, risk }]) => ({ type, count, risk }))
      .sort((a, b) => {
        // Sort by risk level first, then by count
        const riskOrder = { High: 3, Medium: 2, Low: 1, Info: 0 };
        const riskDiff =
          riskOrder[b.risk as keyof typeof riskOrder] - riskOrder[a.risk as keyof typeof riskOrder];
        return riskDiff !== 0 ? riskDiff : b.count - a.count;
      })
      .slice(0, 10); // Get top 10
  }

  /**
   * Organize vulnerability details
   */
  private organizeVulnerabilityDetails(
    result: SecurityScanResult,
    options: VulnerabilityAnalysisOptions,
  ): {
    [key in AlertRisk]: {
      [type: string]: ZAPAlert[];
    };
  } {
    const details: any = {
      [AlertRisk.High]: {},
      [AlertRisk.Medium]: {},
      [AlertRisk.Low]: {},
      [AlertRisk.Info]: {},
    };

    // Filter and organize alerts
    Object.entries(result.alerts).forEach(([risk, alerts]) => {
      if (
        options.minRiskLevel &&
        this.getRiskLevel(risk as AlertRisk) < this.getRiskLevel(options.minRiskLevel)
      ) {
        return;
      }

      alerts.forEach((alert) => {
        const type = alert.alert;
        if (!details[risk][type]) {
          details[risk][type] = [];
        }

        // Clean alert based on options
        const cleanedAlert = this.cleanAlert(alert, options);
        details[risk][type].push(cleanedAlert);
      });
    });

    return details;
  }

  /**
   * Clean alert based on options
   */
  private cleanAlert(alert: ZAPAlert, options: VulnerabilityAnalysisOptions): Partial<ZAPAlert> {
    const cleaned: Partial<ZAPAlert> = {
      alert: alert.alert,
      risk: alert.risk,
      confidence: alert.confidence,
      url: alert.url,
      method: alert.method,
      description: alert.description,
    };

    if (options.includeEvidence && alert.evidence) {
      cleaned.evidence = alert.evidence;
    }

    if (options.includeSolution) {
      cleaned.solution = alert.solution;
    }

    if (options.includeReference && alert.reference) {
      cleaned.reference = alert.reference;
    }

    return cleaned;
  }

  /**
   * Get risk level as number
   */
  private getRiskLevel(risk: AlertRisk): number {
    const levels = {
      [AlertRisk.High]: 3,
      [AlertRisk.Medium]: 2,
      [AlertRisk.Low]: 1,
      [AlertRisk.Info]: 0,
    };
    return levels[risk];
  }

  /**
   * Generate vulnerability report
   */
  public generateReport(report: VulnerabilityReport, outputDir: string): string {
    try {
      const reportPath = join(outputDir, `vulnerability-report-${Date.now()}.html`);
      const html = this.generateHtmlReport(report);
      writeFileSync(reportPath, html);
      logger.info('Vulnerability report generated', { reportPath });
      return reportPath;
    } catch (error) {
      logger.logError('Failed to generate vulnerability report', error);
      throw error;
    }
  }

  /**
   * Generate HTML report
   */
  private generateHtmlReport(report: VulnerabilityReport): string {
    return `
<!DOCTYPE html>
<html>
<head>
  <title>Vulnerability Analysis Report</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h1, h2 { color: #333; }
    .summary { background: #f5f5f5; padding: 20px; border-radius: 5px; }
    .risk-high { color: #d9534f; }
    .risk-medium { color: #f0ad4e; }
    .risk-low { color: #5bc0de; }
    .risk-info { color: #5cb85c; }
    table { width: 100%; border-collapse: collapse; margin: 20px 0; }
    th, td { padding: 10px; text-align: left; border: 1px solid #ddd; }
    th { background: #f5f5f5; }
  </style>
</head>
<body>
  <h1>Vulnerability Analysis Report</h1>

  <div class="summary">
    <h2>Summary</h2>
    <p>Total Vulnerabilities: ${report.summary.total}</p>
    <p class="risk-high">High Risk: ${report.summary.high}</p>
    <p class="risk-medium">Medium Risk: ${report.summary.medium}</p>
    <p class="risk-low">Low Risk: ${report.summary.low}</p>
    <p class="risk-info">Informational: ${report.summary.info}</p>
  </div>

  <h2>Top Vulnerabilities</h2>
  <table>
    <tr>
      <th>Type</th>
      <th>Risk Level</th>
      <th>Count</th>
    </tr>
    ${report.topVulnerabilities
      .map(
        (v) => `
    <tr>
      <td>${v.type}</td>
      <td class="risk-${v.risk.toLowerCase()}">${v.risk}</td>
      <td>${v.count}</td>
    </tr>
    `,
      )
      .join('')}
  </table>

  <h2>Detailed Findings</h2>
  ${Object.entries(report.details)
    .map(
      ([risk, types]) => `
    <h3 class="risk-${risk.toLowerCase()}">${risk} Risk Vulnerabilities</h3>
    ${Object.entries(types)
      .map(
        ([type, alerts]) => `
      <h4>${type} (${alerts.length})</h4>
      <table>
        <tr>
          <th>URL</th>
          <th>Method</th>
          <th>Description</th>
          ${alerts[0].solution ? '<th>Solution</th>' : ''}
        </tr>
        ${alerts
          .map(
            (alert) => `
        <tr>
          <td>${alert.url}</td>
          <td>${alert.method}</td>
          <td>${alert.description}</td>
          ${alert.solution ? `<td>${alert.solution}</td>` : ''}
        </tr>
        `,
          )
          .join('')}
      </table>
    `,
      )
      .join('')}
  `,
    )
    .join('')}
</body>
</html>
    `.trim();
  }
}
